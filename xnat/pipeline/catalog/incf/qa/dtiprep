#!/usr/bin/python

import sys
import xml.dom.minidom

class DTIPrepQCReportReader:

    def __init__(self, fo):
        self.parse(fo)
        return

    def parse(self, fo):
        # file as a whole first; store the slice-wise checking and baseline avaraging sections and parse them separately below
        slicewise_checking = []
        baseline_averaging = []
        self.summary = []
        state = 'start'
        for line in fo:
            line = line.rstrip('\n')
            if state == 'start':
                if line.startswith('================================'):
                    state = 'header'
            elif state == 'header':
                header = line.strip()
                if header in ('Slice-wise checking', 
                              'Baseline averaging', 
                              'QC result summary:'):
                    section = header
                else:
                    section = 'ignore'
                state = 'header2'
            elif state == 'header2':
                if line.startswith('================================'):
                    state = 'section'
            elif state == 'section':
                if line.startswith('================================'):
                    state = 'header'
                elif section == 'Slice-wise checking':
                    slicewise_checking.append(line)
                elif section == 'Baseline averaging':
                    baseline_averaging.append(line)
                elif section == 'QC result summary:':
                    self.summary.append(line.strip())
        # slice-wise checking section
        self.slicewise_parameters = {}
        self.slicewise_artifacts = []
        state = 'start'
        for line in slicewise_checking:
            if state == 'start':
                if line == 'Parameters:':
                    state = 'parameters'
            elif state == 'parameters':
                if line.startswith('======'):
                    state = 'break'
                elif not line.strip():
                    pass
                else:
                    (name, value) = line.strip().split(':')
                    self.slicewise_parameters[name.strip()] = value.strip()
            elif state == 'break':
                if line == 'Slice-wise Check Artifacts:':
                    state = 'table_header'
            elif state == 'table_header':
                if line.startswith('Region'):
                    state = 'table'
            elif state == 'table':
                if not line.strip():
                    state = 'end'
                else:
                    keys = ('region', 'gradient', 'slice', 'correlation')
                    d = dict(zip(keys, line.split()))
                    self.slicewise_artifacts.append(d)
        # baseline averaging
        self.gradient_directions = {}
        state = 'start'
        for line in baseline_averaging:
            if state == 'start':
                if line.startswith('Output Diffusion Gradient direction'):
                    state = 'table_header'
            elif state == 'table_header':
                if not line.strip():
                    pass
                elif line.strip().startswith('#'):
                    state = 'table'
            elif state == 'table':
                if not line.strip():
                    state = 'end'
                else:
                    (gradient, p1, x, y, z, p2) = line.split()
                    self.gradient_directions[int(gradient)] = (x, y, z)
        return

def text_value(el):
    """return the text in the element"""
    s = ''
    for cn in el.childNodes:
        if cn.nodeType == cn.TEXT_NODE:
            s += cn.nodeValue
    return s

def get_child_elements(el):
    """return a list of child elements (not text nodes or others)"""
    child_elements = []
    for cn in el.childNodes:
        if not isinstance(cn, xml.dom.minidom.Element):
            continue
        child_elements.append(cn)
    return child_elements

def process_entry(el):
    """process_entry(element) -> dictionary

    The DTIPrep XML output is basically a bunch of nested <entry> elements with parameter attributes.  We recursively construct a dictionary from this.
    """
    child_elements = get_child_elements(el)
    # special case: a single value
    if len(child_elements) == 1 and child_elements[0].tagName in ('value', 
                                                                  'green', 
                                                                  'red'):
        return text_value(child_elements[0])
    d = {}
    for cn in child_elements:
        if cn.tagName == 'entry':
            param = cn.getAttribute('parameter')
            if not param:
                raise ValueError('empty parameter')
            if param.startswith('gradient_'):
                gradient = int(param[9:])
                d.setdefault('gradients', {})
                d['gradients'][gradient] = process_entry(cn)
            elif el.getAttribute('parameter').startswith('gradient_') \
                 and param == 'SliceWiseCheck':
                # this may contain multiple slice#/correlation pairs, so we can't treat it as a dictionary
                d['SliceWiseCheck'] = process_swc(cn)
                print d['SliceWiseCheck']
            else:
                d[param] = process_entry(cn)
        elif cn.tagName == 'processing':
            d['processing'] = text_value(cn)
        elif cn.tagName == 'value':
            d['value'] = text_value(cn)
    return d

def process_swc(el):
    """process_swc(element) -> dictionary

    Handle an <entry parameter="SliceWiseCheck">, which may contain multiple Slice#/Correlation pairs
    """
    d = {'excludes': []}
    sc = None
    child_elements = get_child_elements(el)
    for ce in child_elements:
        param = ce.getAttribute('parameter')
        if ce.tagName == 'processing':
            d['processing'] = text_value(ce)
        elif ce.tagName == 'entry' and param == 'Slice#':
            val = text_value(get_child_elements(ce)[0])
            sc = [val, None]
        elif ce.tagName == 'entry' and param == 'Correlation':
            val = text_value(get_child_elements(ce)[0])
            sc[1] = val
            d['excludes'].append(sc)
            sc = None
    return d

doc = xml.dom.minidom.parseString(open('600_XMLQCResult.xml').read())
top = doc.getElementsByTagName('QCResultSettings')[0]
xml_data = process_entry(top)

txt_data = DTIPrepQCReportReader(open('2.txt'))

def append_text_element(doc, parent, name, value):
    el = doc.createElement(name)
    el.appendChild(doc.createTextNode(value))
    parent.appendChild(el)
    return

doc = xml.dom.minidom.Document()
root = doc.createElement('incf:DTIPrepQA')
doc.appendChild(root)
root.setAttribute('xmlns:incf', 'http://xnat.incf.org/xnat')
root.setAttribute('xmlns:xnat', 'http://nrg.wustl.edu/xnat')
root.setAttribute('ID', '')

#append_text_element(doc, root, 'xnat:imageSession_ID', experiment_id)
#append_text_element(doc, root, 'source_scan', scan.label())

summary = doc.createElement('summary')
append_text_element(doc, 
                    summary, 
                    'image_origin_check', 
                    xml_data['ImageInformation']['origin'])
append_text_element(doc, 
                    summary, 
                    'image_space_check', 
                    xml_data['ImageInformation']['space'])
append_text_element(doc, 
                    summary, 
                    'image_spaced_direction_check', 
                    xml_data['ImageInformation']['spacedirection'])
append_text_element(doc, 
                    summary, 
                    'image_spacing_check', 
                    xml_data['ImageInformation']['spacing'])
append_text_element(doc, 
                    summary, 
                    'image_size_check', 
                    xml_data['ImageInformation']['size'])
append_text_element(doc, 
                    summary, 
                    'image_gradient_check', 
                    xml_data['DiffusionInformation']['gradient'])
append_text_element(doc, 
                    summary, 
                    'diffusion_measurement_frame_check', 
                    xml_data['DiffusionInformation']['measurementFrame'])
append_text_element(doc, 
                    summary, 
                    'diffusion_slicewise_check', 
                    xml_data['DWI Check']['SliceWiseCheck'])
append_text_element(doc, 
                    summary, 
                    'dwi_interlacewise_check', 
                    xml_data['DWI Check']['InterlaceWiseCheck'])
append_text_element(doc, 
                    summary, 
                    'dwi_gradientwise_check', 
                    xml_data['DWI Check']['GradientWiseCheck'])
root.appendChild(summary)

notes = doc.createElement('Notes')
for note in txt_data.summary:
    append_text_element(doc, notes, 'Note', note)
summary.appendChild(notes)

info = doc.createElement('info')

slicewise_parameters = doc.createElement('slicewise_parameters')
append_text_element(doc, 
                    slicewise_parameters, 
                    'check_times', 
                    txt_data.slicewise_parameters['CheckTimes'])
append_text_element(doc, 
                    slicewise_parameters, 
                    'baseline_stdev_times', 
                    txt_data.slicewise_parameters['BaselineStdevTimes'])
append_text_element(doc, 
                    slicewise_parameters, 
                    'head_skip_ration', 
                    txt_data.slicewise_parameters['HeadSkipRatio'])
append_text_element(doc, 
                    slicewise_parameters, 
                    'gradient_stdev_times', 
                    txt_data.slicewise_parameters['GradientStdevTimes'])
append_text_element(doc, 
                    slicewise_parameters, 
                    'tail_skip_ratio', 
                    txt_data.slicewise_parameters['TailSkipRatio'])
info.appendChild(slicewise_parameters)

gradient_directions = doc.createElement('gradient_directions')
for gradient in sorted(txt_data.gradient_directions):
    el = doc.createElement('gradient_direction')
    value = ' '.join(txt_data.gradient_directions[gradient])
    el.appendChild(doc.createTextNode(value))
    el.setAttribute('number', str(gradient))
    gradient_directions.appendChild(el)
info.appendChild(gradient_directions)

root.appendChild(info)

slicewise_artifacts = doc.createElement('slicewise_artifacts')
for d in txt_data.slicewise_artifacts:
    el = doc.createElement('slicewise_artifact')
    append_text_element(doc, el, 'gradient', d['gradient'])
    append_text_element(doc, el, 'region', d['region'])
    append_text_element(doc, el, 'slice', d['slice'])
    append_text_element(doc, el, 'correlation', d['correlation'])
    slicewise_artifacts.appendChild(el)

root.appendChild(slicewise_artifacts)

gradients = doc.createElement('gradients')

for gradient_number in sorted(xml_data['DWI Check']['gradients']):
    d = xml_data['DWI Check']['gradients'][gradient_number]
    if gradient_number == 3:
        print d
    gradient = doc.createElement('gradient')
    gradient.setAttribute('number', str(gradient_number))
    append_text_element(doc, gradient, 'processing', d['processing'])
    append_text_element(doc, gradient, 'original_dir', d['OriginalDir'])
    append_text_element(doc, gradient, 'replaced_dir', d['ReplacedDir'])
    append_text_element(doc, gradient, 'corrected_dir', d['CorrectedDir'])
    slice_excludes = doc.createElement('slice_excludes')
    for e in d['SliceWiseCheck']['excludes']:
        slice_exclude = doc.createElement('slice_exclude')
        append_text_element(doc, slice_exclude, 'slice', e[0])
        append_text_element(doc, slice_exclude, 'correlation', e[1])
        slice_excludes.appendChild(slice_exclude)
    gradient.appendChild(slice_excludes)
    interlacewise_check = doc.createElement('interlacewise_check')
    append_text_element(doc, 
                        interlacewise_check, 
                        'interlace_angle_x', 
                        d['InterlaceWiseCheck']['InterlaceAngleX'])
    append_text_element(doc, 
                        interlacewise_check, 
                        'interlace_angle_y', 
                        d['InterlaceWiseCheck']['InterlaceAngleY'])
    append_text_element(doc, 
                        interlacewise_check, 
                        'interlace_angle_z', 
                        d['InterlaceWiseCheck']['InterlaceAngleZ'])
    append_text_element(doc, 
                        interlacewise_check, 
                        'interlace_translation_x', 
                        d['InterlaceWiseCheck']['InterlaceTranslationX'])
    append_text_element(doc, 
                        interlacewise_check, 
                        'interlace_translation_y', 
                        d['InterlaceWiseCheck']['InterlaceTranslationY'])
    append_text_element(doc, 
                        interlacewise_check, 
                        'interlace_translation_z', 
                        d['InterlaceWiseCheck']['InterlaceTranslationZ'])
    append_text_element(doc, 
                        interlacewise_check, 
                        'interlace_metric', 
                        d['InterlaceWiseCheck']['InterlaceMetric(MI)'])
    if gradient_number == 0:
        corr = d['InterlaceWiseCheck']['InterlaceCorrelation_Baseline']
    else:
        corr = d['InterlaceWiseCheck']['InterlaceCorrelation']
    append_text_element(doc, 
                        interlacewise_check, 
                        'interlace_correlation_baseline', 
                        corr)
    gradient.appendChild(interlacewise_check)
    gradientwise_check = doc.createElement('gradientwise_check')
    append_text_element(doc, 
                        gradientwise_check, 
                        'gradient_angle_x', 
                        d['GradientWiseCheck']['GradientAngleX'])
    append_text_element(doc, 
                        gradientwise_check, 
                        'gradient_angle_y', 
                        d['GradientWiseCheck']['GradientAngleY'])
    append_text_element(doc, 
                        gradientwise_check, 
                        'gradient_angle_z', 
                        d['GradientWiseCheck']['GradientAngleZ'])
    append_text_element(doc, 
                        gradientwise_check, 
                        'gradient_translation_x', 
                        d['GradientWiseCheck']['GradientTranslationX'])
    append_text_element(doc, 
                        gradientwise_check, 
                        'gradient_translation_y', 
                        d['GradientWiseCheck']['GradientTranslationY'])
    append_text_element(doc, 
                        gradientwise_check, 
                        'gradient_translation_z', 
                        d['GradientWiseCheck']['GradientTranslationZ'])
    append_text_element(doc, 
                        gradientwise_check, 
                        'gradient_metric', 
                        d['GradientWiseCheck']['GradientMetric(MI)'])
    gradient.appendChild(gradientwise_check)

    append_text_element(doc, gradient, 'qc_index', d['QC_Index'])

    gradients.appendChild(gradient)

root.appendChild(gradients)

print doc.toprettyxml()

sys.exit(0)

# eof
